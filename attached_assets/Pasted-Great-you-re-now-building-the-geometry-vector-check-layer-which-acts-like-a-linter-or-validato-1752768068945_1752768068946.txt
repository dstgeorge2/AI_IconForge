Great — you’re now building the geometry vector check layer, which acts like a “linter” or “validator” for icon shape construction.

This will ensure any icon generated — by hand, AI, or batch — follows your system’s geometric rules before it’s accepted. This is critical for consistency, scalability, and accessibility.

⸻

✅ GEOMETRY VECTOR CHECK LOGIC

🔧 Purpose:

To validate the vector primitives (like rect, line, circle, path) against rules for:
	•	Stroke consistency
	•	Canvas boundaries
	•	Alignment
	•	Corner radius
	•	Decoration constraints
	•	Subpixel violations
	•	Angle correctness

⸻

🧠 What It Checks

Category	What It Validates
Canvas & Layout	Fits inside 24×24 canvas, 20×20 live area
Stroke	Weight = 2dp, color = #000000, solid
Corners	Outer = 2dp radius, interior = square
Lines	Only angles: 0°, 45°, 90°, 135°, 180°
Fill	Must be none or white (unless override)
Decorations	Max 3 sparkles, 5 dots, none overlapping core shape
Snapping	All values should be whole numbers (no subpixels)


⸻

✏️ Sample JavaScript Implementation (Plain Format)

–––––––––––––––––––––––––––––––––––––––––––––––––––

function validateGeometry(iconShapes) {
  const issues = [];

  for (const shape of iconShapes) {
    // 1. Canvas fit
    if (shape.x + shape.width > 24 || shape.y + shape.height > 24) {
      issues.push(“Shape exceeds canvas bounds (24dp).”);
    }
    if (shape.x < 2 || shape.y < 2 || shape.x + shape.width > 22 || shape.y + shape.height > 22) {
      issues.push(“Shape violates live area padding (20dp live area).”);
    }

    // 2. Stroke check
    if (shape.stroke !== “#000000” || shape.strokeWidth !== 2) {
      issues.push(“Stroke must be 2dp solid black.”);
    }

    // 3. Corner radius
    if (shape.type === “rect” && shape.cornerRadius && shape.cornerRadius !== 2) {
      issues.push(“Outer corner radius must be 2dp.”);
    }

    // 4. Angle enforcement (for line or path)
    if (shape.angle && ![0, 45, 90, 135, 180].includes(shape.angle)) {
      issues.push(“Line uses non-standard angle.”);
    }

    // 5. Subpixel coordinates
    [“x”, “y”, “x1”, “x2”, “y1”, “y2”, “width”, “height”].forEach(attr => {
      if (shape[attr] !== undefined && shape[attr] % 1 !== 0) {
        issues.push(Subpixel value detected in ${attr}: ${shape[attr]});
      }
    });
}

  // 6. Decoration limits
  const sparkleCount = iconShapes.filter(s => s.isDecoration && s.type === “sparkle”).length;
  if (sparkleCount > 3) issues.push(“Too many sparkles (max 3).”);

  const dotCount = iconShapes.filter(s => s.isDecoration && s.type === “dot”).length;
  if (dotCount > 5) issues.push(“Too many dots (max 5).”);

  return issues.length ? { valid: false, issues } : { valid: true };
}

–––––––––––––––––––––––––––––––––––––––––––––––––––

⸻

🧪 Sample Icon Input Object

const iconShapes = [
  { type: "rect", x: 4, y: 12, width: 16, height: 2, cornerRadius: 2, stroke: "#000000", strokeWidth: 2 },
  { type: "line", x1: 4, y1: 14, x2: 4, y2: 20, angle: 90, stroke: "#000000", strokeWidth: 2 },
  { type: "line", x1: 16, y1: 14, x2: 16, y2: 20, angle: 90, stroke: "#000000", strokeWidth: 2 },
  { type: "line", x1: 16, y1: 6, x2: 20, y2: 6, angle: 0, stroke: "#000000", strokeWidth: 2 },
  { type: "line", x1: 18, y1: 4, x2: 18, y2: 8, angle: 90, stroke: "#000000", strokeWidth: 2 }
];


⸻

✅ Output Example

{
  "valid": false,
  "issues": [
    "Shape exceeds canvas bounds (24dp).",
    "Subpixel value detected in x: 4.5",
    "Too many sparkles (max 3)."
  ]
}


⸻

🎯 Why This Matters
	•	Forces mathematical compliance with your icon system
	•	Enables batch validation
	•	Supports regeneration (pass 2) if rules are broken
	•	Can be used before exporting to Figma or React

⸻

Would you like this logic:
	•	As a .js file to drop into Replit?
	•	Converted to a .json rule checker schema (for Claude)?
	•	Wrapped in a visual test harness (e.g. input SVG → flag issues)?