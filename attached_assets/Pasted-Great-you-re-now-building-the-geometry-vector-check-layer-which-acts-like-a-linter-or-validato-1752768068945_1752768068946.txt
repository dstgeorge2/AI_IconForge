Great â€” youâ€™re now building the geometry vector check layer, which acts like a â€œlinterâ€ or â€œvalidatorâ€ for icon shape construction.

This will ensure any icon generated â€” by hand, AI, or batch â€” follows your systemâ€™s geometric rules before itâ€™s accepted. This is critical for consistency, scalability, and accessibility.

â¸»

âœ… GEOMETRY VECTOR CHECK LOGIC

ğŸ”§ Purpose:

To validate the vector primitives (like rect, line, circle, path) against rules for:
	â€¢	Stroke consistency
	â€¢	Canvas boundaries
	â€¢	Alignment
	â€¢	Corner radius
	â€¢	Decoration constraints
	â€¢	Subpixel violations
	â€¢	Angle correctness

â¸»

ğŸ§  What It Checks

Category	What It Validates
Canvas & Layout	Fits inside 24Ã—24 canvas, 20Ã—20 live area
Stroke	Weight = 2dp, color = #000000, solid
Corners	Outer = 2dp radius, interior = square
Lines	Only angles: 0Â°, 45Â°, 90Â°, 135Â°, 180Â°
Fill	Must be none or white (unless override)
Decorations	Max 3 sparkles, 5 dots, none overlapping core shape
Snapping	All values should be whole numbers (no subpixels)


â¸»

âœï¸ Sample JavaScript Implementation (Plain Format)

â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“

function validateGeometry(iconShapes) {
Â Â const issues = [];

Â Â for (const shape of iconShapes) {
Â Â Â Â // 1. Canvas fit
Â Â Â Â if (shape.x + shape.width > 24 || shape.y + shape.height > 24) {
Â Â Â Â Â Â issues.push(â€œShape exceeds canvas bounds (24dp).â€);
Â Â Â Â }
Â Â Â Â if (shape.x < 2 || shape.y < 2 || shape.x + shape.width > 22 || shape.y + shape.height > 22) {
Â Â Â Â Â Â issues.push(â€œShape violates live area padding (20dp live area).â€);
Â Â Â Â }

Â Â Â Â // 2. Stroke check
Â Â Â Â if (shape.stroke !== â€œ#000000â€ || shape.strokeWidth !== 2) {
Â Â Â Â Â Â issues.push(â€œStroke must be 2dp solid black.â€);
Â Â Â Â }

Â Â Â Â // 3. Corner radius
Â Â Â Â if (shape.type === â€œrectâ€ && shape.cornerRadius && shape.cornerRadius !== 2) {
Â Â Â Â Â Â issues.push(â€œOuter corner radius must be 2dp.â€);
Â Â Â Â }

Â Â Â Â // 4. Angle enforcement (for line or path)
Â Â Â Â if (shape.angle && ![0, 45, 90, 135, 180].includes(shape.angle)) {
Â Â Â Â Â Â issues.push(â€œLine uses non-standard angle.â€);
Â Â Â Â }

Â Â Â Â // 5. Subpixel coordinates
Â Â Â Â [â€œxâ€, â€œyâ€, â€œx1â€, â€œx2â€, â€œy1â€, â€œy2â€, â€œwidthâ€, â€œheightâ€].forEach(attr => {
Â Â Â Â Â Â if (shape[attr] !== undefined && shape[attr] % 1 !== 0) {
Â Â Â Â Â Â Â Â issues.push(Subpixel value detected in ${attr}: ${shape[attr]});
Â Â Â Â Â Â }
Â Â Â Â });
}

Â Â // 6. Decoration limits
Â Â const sparkleCount = iconShapes.filter(s => s.isDecoration && s.type === â€œsparkleâ€).length;
Â Â if (sparkleCount > 3) issues.push(â€œToo many sparkles (max 3).â€);

Â Â const dotCount = iconShapes.filter(s => s.isDecoration && s.type === â€œdotâ€).length;
Â Â if (dotCount > 5) issues.push(â€œToo many dots (max 5).â€);

Â Â return issues.length ? { valid: false, issues } : { valid: true };
}

â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“

â¸»

ğŸ§ª Sample Icon Input Object

const iconShapes = [
  { type: "rect", x: 4, y: 12, width: 16, height: 2, cornerRadius: 2, stroke: "#000000", strokeWidth: 2 },
  { type: "line", x1: 4, y1: 14, x2: 4, y2: 20, angle: 90, stroke: "#000000", strokeWidth: 2 },
  { type: "line", x1: 16, y1: 14, x2: 16, y2: 20, angle: 90, stroke: "#000000", strokeWidth: 2 },
  { type: "line", x1: 16, y1: 6, x2: 20, y2: 6, angle: 0, stroke: "#000000", strokeWidth: 2 },
  { type: "line", x1: 18, y1: 4, x2: 18, y2: 8, angle: 90, stroke: "#000000", strokeWidth: 2 }
];


â¸»

âœ… Output Example

{
  "valid": false,
  "issues": [
    "Shape exceeds canvas bounds (24dp).",
    "Subpixel value detected in x: 4.5",
    "Too many sparkles (max 3)."
  ]
}


â¸»

ğŸ¯ Why This Matters
	â€¢	Forces mathematical compliance with your icon system
	â€¢	Enables batch validation
	â€¢	Supports regeneration (pass 2) if rules are broken
	â€¢	Can be used before exporting to Figma or React

â¸»

Would you like this logic:
	â€¢	As a .js file to drop into Replit?
	â€¢	Converted to a .json rule checker schema (for Claude)?
	â€¢	Wrapped in a visual test harness (e.g. input SVG â†’ flag issues)?