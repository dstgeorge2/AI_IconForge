Hereâ€™s a complete style guide rewritten for developers and product builders â€” in plain English, JavaScript logic, and app development mindset. This is structured so you can build and enforce it in code.

â¸»

ðŸ§­ Vectra Icon System: Developer-Ready Style Guide

This guide is made for app builders, not just designers â€” itâ€™s written so you can encode the icon logic, validate icons programmatically, and generate them dynamically.

â¸»

ðŸ”§ 1. STROKES

âœ… Plain Rules
	â€¢	Use 2dp stroke width on all shapes
	â€¢	Lines must be solid, black (#000000)
	â€¢	Rounded corners on outer shapes (2dp)
	â€¢	Square corners on interior joins unless clarity is improved with round
	â€¢	Stroke ends must be squared or clipped at 45Â°

ðŸ’¡ Dev Logic

const STROKE_WIDTH = 2;
const STROKE_COLOR = '#000000';
const OUTER_CORNER_RADIUS = 2;
const INTERIOR_CORNER_STYLE = 'square';


â¸»

ðŸ§± 2. CANVAS & GRID

âœ… Plain Rules
	â€¢	Icons sit in a 24 x 24dp canvas
	â€¢	Live area is 20 x 20dp (centered)
	â€¢	Must leave 2dp padding on all sides
	â€¢	All points snap to whole pixels (no subpixels)

ðŸ’¡ Dev Logic

const CANVAS_SIZE = 24;
const LIVE_AREA = 20;
const PADDING = (CANVAS_SIZE - LIVE_AREA) / 2; // = 2dp
function snapToGrid(val) {
  return Math.round(val); // no decimal
}


â¸»

ðŸ§  3. SHAPE CONSTRUCTION

âœ… Plain Rules
	â€¢	Use only geometric primitives: rect, circle, line, path
	â€¢	Combine to form metaphors (e.g., folder = rectangle + top tab)
	â€¢	Favor symmetry and centered layout
	â€¢	Micro-asymmetry allowed for balance

ðŸ’¡ Dev Logic

function drawRect(x, y, width, height, rx = OUTER_CORNER_RADIUS) {
  return `<rect x="${snapToGrid(x)}" y="${snapToGrid(y)}" width="${width}" height="${height}" rx="${rx}" ry="${rx}" />`;
}

function drawLine(x1, y1, x2, y2) {
  return `<line x1="${snapToGrid(x1)}" y1="${snapToGrid(y1)}" x2="${snapToGrid(x2)}" y2="${snapToGrid(y2)}" />`;
}


â¸»

âœ¨ 4. DECORATIONS (Sparkles & Dots)

âœ… Plain Rules
	â€¢	Max 3 sparkles, 4-point style
	â€¢	Sparkles randomly rotated 15â€“30Â°
	â€¢	Dots: â‰¤1.5dp, max 5, only to indicate action/charm

ðŸ’¡ Dev Logic

function drawSparkle(x, y, rotationDeg = 20) {
  return `<use href="#sparkle" transform="translate(${x}, ${y}) rotate(${rotationDeg})" />`;
}

function drawDot(x, y, radius = 0.75) {
  return `<circle cx="${x}" cy="${y}" r="${radius}" />`;
}


â¸»

ðŸŽ¨ 5. FILL AND COLOR

âœ… Plain Rules
	â€¢	Default: no fill (line icon)
	â€¢	Allow fills only if:
	â€¢	Shape is fully enclosed
	â€¢	It clarifies the metaphor (e.g., house wall)
	â€¢	Never use gradients
	â€¢	Use #FFFFFF for any fill

ðŸ’¡ Dev Logic

const DEFAULT_FILL = 'none';
const ALLOWED_FILL = '#FFFFFF';
function getFill(fillAllowed = false) {
  return fillAllowed ? ALLOWED_FILL : DEFAULT_FILL;
}


â¸»

ðŸ§­ 6. PERSPECTIVE

âœ… Plain Rules
	â€¢	Flat view only â€” front or side
	â€¢	No 3D tilt, depth simulation, or shadow
	â€¢	Everything must feel â€œdrawn on paperâ€ not rendered

ðŸ’¡ Dev Logic

// No perspective projection or skewing transforms allowed
// Only use scale, rotate, and translate


â¸»

ðŸŽ› 7. COMPOSITION

âœ… Plain Rules
	â€¢	Center the icon within the live area
	â€¢	Favor optical balance over strict math centering
	â€¢	Icons can suggest motion (e.g., arrow curve), but should feel stable

ðŸ’¡ Dev Logic

function centerIcon(x, y, width, height) {
  const offset = (CANVAS_SIZE - width) / 2;
  return { x: snapToGrid(x + offset), y: snapToGrid(y + offset) };
}


â¸»

ðŸ” 8. ACCESSIBILITY & SCALABILITY

âœ… Plain Rules
	â€¢	Must work at 16dp, 20dp, 24dp, 48dp
	â€¢	Contrast ratio must be at least 4.5:1
	â€¢	Icons must not rely on color to convey meaning

ðŸ’¡ Dev Logic

// Use black-on-white by default; ensure contrast never drops
const MIN_CONTRAST_RATIO = 4.5;


â¸»

ðŸ§ª 9. VALIDATION RULES

Use this to write a validateIcon() function in JS:

function validateIcon(icon) {
  const errors = [];

  if (icon.strokeWidth !== 2) errors.push('Stroke width must be 2dp');
  if (icon.canvasSize !== 24) errors.push('Canvas size must be 24dp');
  if (icon.containsSubpixels) errors.push('Subpixel points are not allowed');
  if (icon.decoration.sparkles.length > 3) errors.push('Too many sparkles');
  if (icon.decorations.dots.length > 5) errors.push('Too many dots');
  if (icon.usesGradient) errors.push('Gradients are not allowed');
  if (!icon.accessibility.contrastPasses) errors.push('Fails contrast ratio');

  return errors.length > 0 ? errors : ['PASS'];
}


â¸»

ðŸ“¦ 10. OUTPUT FORMAT (Per Icon)

Each icon should output like this:

export const navigation_home = {
  name: "navigation_home",
  svg: "<svg viewBox='0 0 24 24' ...>...</svg>",
  tags: ["navigation", "dashboard", "entry_point"],
  metadata: {
    strokeWidth: 2,
    fillUsed: false,
    opticalAdjustments: true,
    validated: true
  }
}


â¸»

ðŸ”¥ BONUS: Built-in Icon Generator Function

function generateIcon({ name, primaryShape, decorations = [] }) {
  const svgParts = [];

  // Primary shape (e.g., house)
  svgParts.push(drawRect(4, 10, 16, 10));
  svgParts.push(drawLine(4, 10, 12, 2));
  svgParts.push(drawLine(12, 2, 20, 10));

  // Add decorations
  decorations.forEach(dec => {
    if (dec.type === 'sparkle') svgParts.push(drawSparkle(dec.x, dec.y, dec.rotate));
    if (dec.type === 'dot') svgParts.push(drawDot(dec.x, dec.y));
  });

  return {
    name,
    svg: `<svg viewBox="0 0 24 24" fill="none" stroke="${STROKE_COLOR}" stroke-width="${STROKE_WIDTH}" stroke-linecap="square">${svgParts.join('\n')}</svg>`,
    tags: [],
    metadata: { validated: true }
  };
}


â¸»

Would you like this bootstrapped into a Replit-ready app, a Figma plugin, or a Node.js CLI icon generator? I can also write the validator module or geometry parser next.